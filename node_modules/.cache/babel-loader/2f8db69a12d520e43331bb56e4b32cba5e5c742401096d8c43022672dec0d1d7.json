{"ast":null,"code":"'use strict';\n\nconst isObj = require('is-obj');\nconst disallowedKeys = new Set(['__proto__', 'prototype', 'constructor']);\nconst isValidPath = pathSegments => !pathSegments.some(segment => disallowedKeys.has(segment));\nfunction getPathSegments(path) {\n  const pathArray = path.split('.');\n  const parts = [];\n  for (let i = 0; i < pathArray.length; i++) {\n    let p = pathArray[i];\n    while (p[p.length - 1] === '\\\\' && pathArray[i + 1] !== undefined) {\n      p = p.slice(0, -1) + '.';\n      p += pathArray[++i];\n    }\n    parts.push(p);\n  }\n  if (!isValidPath(parts)) {\n    return [];\n  }\n  return parts;\n}\nmodule.exports = {\n  get(object, path, value) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return value === undefined ? object : value;\n    }\n    const pathArray = getPathSegments(path);\n    if (pathArray.length === 0) {\n      return;\n    }\n    for (let i = 0; i < pathArray.length; i++) {\n      object = object[pathArray[i]];\n      if (object === undefined || object === null) {\n        // `object` is either `undefined` or `null` so we want to stop the loop, and\n        // if this is not the last bit of the path, and\n        // if it did't return `undefined`\n        // it would return `null` if `object` is `null`\n        // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n        if (i !== pathArray.length - 1) {\n          return value;\n        }\n        break;\n      }\n    }\n    return object === undefined ? value : object;\n  },\n  set(object, path, value) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return object;\n    }\n    const root = object;\n    const pathArray = getPathSegments(path);\n    for (let i = 0; i < pathArray.length; i++) {\n      const p = pathArray[i];\n      if (!isObj(object[p])) {\n        object[p] = {};\n      }\n      if (i === pathArray.length - 1) {\n        object[p] = value;\n      }\n      object = object[p];\n    }\n    return root;\n  },\n  delete(object, path) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return false;\n    }\n    const pathArray = getPathSegments(path);\n    for (let i = 0; i < pathArray.length; i++) {\n      const p = pathArray[i];\n      if (i === pathArray.length - 1) {\n        delete object[p];\n        return true;\n      }\n      object = object[p];\n      if (!isObj(object)) {\n        return false;\n      }\n    }\n  },\n  has(object, path) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return false;\n    }\n    const pathArray = getPathSegments(path);\n    if (pathArray.length === 0) {\n      return false;\n    }\n\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let i = 0; i < pathArray.length; i++) {\n      if (isObj(object)) {\n        if (!(pathArray[i] in object)) {\n          return false;\n        }\n        object = object[pathArray[i]];\n      } else {\n        return false;\n      }\n    }\n    return true;\n  }\n};","map":{"version":3,"names":["isObj","require","disallowedKeys","Set","isValidPath","pathSegments","some","segment","has","getPathSegments","path","pathArray","split","parts","i","length","p","undefined","slice","push","module","exports","get","object","value","set","root","delete"],"sources":["/Users/rhysgregory/node_modules/dot-prop/index.js"],"sourcesContent":["'use strict';\nconst isObj = require('is-obj');\n\nconst disallowedKeys = new Set([\n\t'__proto__',\n\t'prototype',\n\t'constructor'\n]);\n\nconst isValidPath = pathSegments => !pathSegments.some(segment => disallowedKeys.has(segment));\n\nfunction getPathSegments(path) {\n\tconst pathArray = path.split('.');\n\tconst parts = [];\n\n\tfor (let i = 0; i < pathArray.length; i++) {\n\t\tlet p = pathArray[i];\n\n\t\twhile (p[p.length - 1] === '\\\\' && pathArray[i + 1] !== undefined) {\n\t\t\tp = p.slice(0, -1) + '.';\n\t\t\tp += pathArray[++i];\n\t\t}\n\n\t\tparts.push(p);\n\t}\n\n\tif (!isValidPath(parts)) {\n\t\treturn [];\n\t}\n\n\treturn parts;\n}\n\nmodule.exports = {\n\tget(object, path, value) {\n\t\tif (!isObj(object) || typeof path !== 'string') {\n\t\t\treturn value === undefined ? object : value;\n\t\t}\n\n\t\tconst pathArray = getPathSegments(path);\n\t\tif (pathArray.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < pathArray.length; i++) {\n\t\t\tobject = object[pathArray[i]];\n\n\t\t\tif (object === undefined || object === null) {\n\t\t\t\t// `object` is either `undefined` or `null` so we want to stop the loop, and\n\t\t\t\t// if this is not the last bit of the path, and\n\t\t\t\t// if it did't return `undefined`\n\t\t\t\t// it would return `null` if `object` is `null`\n\t\t\t\t// but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n\t\t\t\tif (i !== pathArray.length - 1) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn object === undefined ? value : object;\n\t},\n\n\tset(object, path, value) {\n\t\tif (!isObj(object) || typeof path !== 'string') {\n\t\t\treturn object;\n\t\t}\n\n\t\tconst root = object;\n\t\tconst pathArray = getPathSegments(path);\n\n\t\tfor (let i = 0; i < pathArray.length; i++) {\n\t\t\tconst p = pathArray[i];\n\n\t\t\tif (!isObj(object[p])) {\n\t\t\t\tobject[p] = {};\n\t\t\t}\n\n\t\t\tif (i === pathArray.length - 1) {\n\t\t\t\tobject[p] = value;\n\t\t\t}\n\n\t\t\tobject = object[p];\n\t\t}\n\n\t\treturn root;\n\t},\n\n\tdelete(object, path) {\n\t\tif (!isObj(object) || typeof path !== 'string') {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst pathArray = getPathSegments(path);\n\n\t\tfor (let i = 0; i < pathArray.length; i++) {\n\t\t\tconst p = pathArray[i];\n\n\t\t\tif (i === pathArray.length - 1) {\n\t\t\t\tdelete object[p];\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tobject = object[p];\n\n\t\t\tif (!isObj(object)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t},\n\n\thas(object, path) {\n\t\tif (!isObj(object) || typeof path !== 'string') {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst pathArray = getPathSegments(path);\n\t\tif (pathArray.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// eslint-disable-next-line unicorn/no-for-loop\n\t\tfor (let i = 0; i < pathArray.length; i++) {\n\t\t\tif (isObj(object)) {\n\t\t\t\tif (!(pathArray[i] in object)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tobject = object[pathArray[i]];\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}